<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bulk Courier Uploader - Eri Shipping Hub (Enhanced with Name/Comment)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    /* Basic styling for feedback messages */
    .feedback-section p {
      margin-bottom: 0.25rem; /* Tighter spacing for list items */
      padding: 0.2rem 0;
    }
    .feedback-section h5 {
        margin-top: 1rem;
        margin-bottom: 0.5rem;
    }
    .spinner-border {
        display: inline-block;
        width: 1.5rem;
        height: 1.5rem;
        vertical-align: middle;
        margin-right: 0.5rem;
    }
    pre {
        white-space: pre-wrap; /* Allow example text to wrap */
        word-wrap: break-word;
    }
  </style>
</head>
<body class="bg-light">
  <div class="container py-5">
    <h3 class="text-center mb-4">ğŸ“¦ Bulk Courier Uploader (Enhanced)</h3>

    <div class="card mb-4">
        <div class="card-body">
            <h5 class="card-title">Instructions for Pasting Data:</h5>
            <p class="card-text">Paste your courier entries below. Each entry should be grouped together and include the following lines. Order within a group is flexible, but each line must start with the correct indicator:</p>
            <ul>
                <li>ğŸ“… **Date:** Must be on a line starting with 'ğŸ“… ' followed by the date in `DD/MM/YYYY` format (e.g., `ğŸ“… 27/04/2025`). This line signals the start of a new courier group.</li>
                <li>ğŸ›£ï¸ **Route:** Must be on a line containing 'áˆ˜áŠ•áŒˆá‹²:' or 'â†’' or 'to', specifying the route like `áˆ˜áŠ•áŒˆá‹²: From â†’ To` or `From to To`.</li>
                <li>ğŸ“ **Contact(s):** Must be on a line starting with 'ğŸ“ ' or 'áˆµáˆáŠª' or 'Phone', followed by one or more phone numbers separated by `/` or `,`. Each phone number will create a separate courier entry with the same date/route/name/comment. (e.g., `ğŸ“ 0910111030 / 0944406293`).</li>
                 <li>ğŸ‘¤ **Name / áˆµáˆ (Optional):** Must be on a line starting with 'name:' or 'áˆµáˆ:'. (e.g., `name: John Doe`). If not provided, a default name like '0050', '0051', etc., will be assigned.</li>
                <li>ğŸ“ **Comment / áŠ•á‰¥áˆ¨á‰µ (Optional):** Must be on a line starting with 'comment:' or 'áŠ•á‰¥áˆ¨á‰µ:'. (e.g., `comment: 2 boxes, clothes`).</li>
            </ul>
            <p class="card-text fw-bold">Example:</p>
            <pre class="bg-light p-2 border rounded">
ğŸ“… 27/04/2025
name: John Doe
áˆ˜áŠ•áŒˆá‹²: Canada â†’ Eritrea
ğŸ“ 0910111030 / 0944406293
comment: Suitcase with gifts

ğŸ“… 28/04/2025
From to Ethiopia
ğŸ“ 0912345678
# No name provided for this entry, a default will be assigned
comment: Small package</pre>
             <p class="card-text text-muted"><small>Duplicate entries (same date, from, to, contact, *and* name) will be skipped.</small></p>
        </div>
    </div>


    <div class="mb-3">
      <label for="bulkInput" class="form-label">Paste entries below:</label>
      <textarea id="bulkInput" class="form-control" rows="12" placeholder="Paste your structured data here following the instructions above..."></textarea>
    </div>

    <button id="submitBulk" class="btn btn-primary">
        <span id="buttonText">ğŸš€ Add All Couriers</span>
        <span id="loadingSpinner" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display: none;"></span>
    </button>
    <p id="overallResult" class="mt-3 fw-bold"></p>

    <div class="feedback-section mt-4">
        <div id="addedList"></div>
        <div id="skippedList"></div>
        <div id="errorList"></div>
    </div>

  </div>

  <script type="module">
    // IMPORTANT: Replace with your actual Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyCapqLcvAVvBtSvUgtvLX4gx7nN5XSjAtQ",
      authDomain: "erishipping-e4532.firebaseapp.com",
      projectId: "erishipping-e4532",
      storageBucket: "erishipping-e4532.appspot.com",
      messagingSenderId: "388550131049",
      appId: "1:388550131049:web:e9ac1784ab8e5fabc811f8"
    };

    // Initialize Firebase ONLY if not already initialized (important in some frameworks)
    import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
    import { getFirestore, collection, addDoc, serverTimestamp, query, where, getDocs } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore.js";

    const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp();
    const db = getFirestore(app);
    const courierRef = collection(db, "couriers");

    const bulkInput = document.getElementById("bulkInput");
    const overallResult = document.getElementById("overallResult");
    const addedList = document.getElementById("addedList");
    const skippedList = document.getElementById("skippedList");
    const errorList = document.getElementById("errorList");
    const submitBtn = document.getElementById("submitBulk");
    const buttonText = document.getElementById("buttonText");
    const loadingSpinner = document.getElementById("loadingSpinner");


    const normalizeCountry = (place) => {
      const map = {
        "áŠ£á‹²áˆµ": "Ethiopia",
        "áŠ¡áŒ‹áŠ•á‹³": "Uganda",
        "áŠ£áˆµáˆ˜áˆ«": "Eritrea",
        "áŠ«áŠ“á‹³": "Canada",
        "áŠ¤áˆ­á‰µáˆ«": "Eritrea",
        "á‰¶áˆ®áŠ•á‰¶": "Canada",
        "áŠ«áˆá“áˆ‹": "Uganda",
        "áŠ¢á‰²á‹®á•á‹«": "Ethiopia",
        "áŠ£áˆ˜áˆªáŠ«": "USA",
        "áˆµá‹Šá‹˜áˆ­áˆ‹áŠ•á‹µ": "Switzerland",
        "á‰±áˆ­áŠª": "Turkey",
        "áŠ¥áŠ•áŒáˆŠá‹": "England",
        "á‹°áŠ•áˆ›áˆ­áŠ­": "Denmark",
        "áŒˆáˆ­áˆ˜áŠ•": "Germany",
        "áˆáˆ¨áŠ•áˆ³": "France",
        "áŠ¢á‰³áˆá‹«": "Italy",
        "á‹°á‰¡á‰¥ áŠ£ááˆªá‰ƒ": "South Africa",
        "áŠ¥áŒá•á‰µ": "Egypt"
      };
      const trimmedPlace = place.trim();
      return map[trimmedPlace] || trimmedPlace;
    };

    // Basic date validation DD/MM/YYYY
    const isValidDate = (dateStr) => {
        if (!/^\d{2}\/\d{2}\/\d{4}$/.test(dateStr)) return false;
        const [day, month, year] = dateStr.split('/').map(Number);
        const date = new Date(year, month - 1, day);
        return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
    };

    async function isDuplicateEntry(date, from, to, contact, name) {
        // Basic validation before querying
        if (!date || !from || !to || !contact || contact.length < 6) return false;
        // Include name in duplicate check
        if (typeof name !== 'string') name = ''; // Ensure name is a string for the query

        const q = query(
            courierRef,
            where("date", "==", date),
            where("from", "==", from),
            where("to", "==", to),
            where("contact", "==", contact),
            where("name", "==", name) // Include name in duplicate check
        );
        const querySnapshot = await getDocs(q);
        return !querySnapshot.empty;
    }

    submitBtn.addEventListener("click", async () => {
        // Reset feedback areas
        overallResult.textContent = "";
        addedList.innerHTML = "";
        skippedList.innerHTML = "";
        errorList.innerHTML = "";
        overallResult.className = "mt-3 fw-bold"; // Reset class

        // Show loading spinner
        submitBtn.disabled = true;
        buttonText.style.display = 'none';
        loadingSpinner.style.display = 'inline-block';

        const lines = bulkInput.value.trim().split("\n");
        // Added name and comment to currentBlock structure
        let currentBlock = { date: '', from: '', to: '', phones: [], name: '', comment: '', lineNumber: -1 };
        const entriesToProcess = [];
        const errors = [];
        let currentLineNumber = 0;

        // --- Step 1: Parse the input and group data ---
        for (let line of lines) {
            currentLineNumber++;
            const trimmedLine = line.trim();
            if (!trimmedLine || trimmedLine.startsWith('#')) continue; // Skip empty lines or comment lines starting with #

            if (trimmedLine.startsWith('ğŸ“…')) {
                // Start of a new block, push the previous one if valid
                if (currentBlock.date || currentBlock.from || currentBlock.to || currentBlock.phones.length > 0 || currentBlock.name || currentBlock.comment) {
                     // Validate and push the completed block
                    entriesToProcess.push({...currentBlock}); // Push a copy
                }
                // Start a new block
                const dateMatch = trimmedLine.match(/\d{2}\/\d{2}\/\d{4}/);
                if (dateMatch && isValidDate(dateMatch[0])) {
                    // Reset all fields for the new block
                    currentBlock = { date: dateMatch[0], from: '', to: '', phones: [], name: '', comment: '', lineNumber: currentLineNumber };
                } else {
                    // Invalid date format or missing date after symbol
                     errors.push({ originalText: line, reason: "Invalid or missing date format (DD/MM/YYYY) after ğŸ“… symbol.", lineNumber: currentLineNumber });
                     // Still reset block but indicate error context
                     currentBlock = { date: '', from: '', to: '', phones: [], name: '', comment: '', lineNumber: currentLineNumber };
                }

            } else if (/áˆ˜áŠ•áŒˆá‹²\:|â†’|to/i.test(trimmedLine)) {
                if (!currentBlock.date) {
                     errors.push({ originalText: line, reason: "Route found before a valid Date (ğŸ“… DD/MM/YYYY).", lineNumber: currentLineNumber });
                     continue;
                }
                 // Allow updating route if found later in block? Or flag duplicate? Flag duplicate is safer.
                if (currentBlock.from || currentBlock.to) {
                     errors.push({ originalText: line, reason: "Duplicate Route line within the same entry block.", lineNumber: currentLineNumber });
                     continue;
                }
                let parts = trimmedLine.split(/â†’|to/i);
                if (parts.length === 2) {
                    currentBlock.from = parts[0].replace(/áˆ˜áŠ•áŒˆá‹²\:/i, "").trim();
                    currentBlock.to = parts[1].trim();
                } else {
                    errors.push({ originalText: line, reason: "Could not parse route. Expected format like 'From â†’ To' or 'From to To'.", lineNumber: currentLineNumber });
                }

            } else if (/ğŸ“|áˆµáˆáŠª|Phone/i.test(trimmedLine)) {
                 if (!currentBlock.date) {
                     errors.push({ originalText: line, reason: "Contact found before a valid Date (ğŸ“… DD/MM/YYYY).", lineNumber: currentLineNumber });
                     continue;
                }
                 // Allow adding multiple phone lines to the same block
                const phonePart = trimmedLine.replace(/.*(ğŸ“|áˆµáˆáŠª|Phone)[:\s]?/i, '').trim();
                if (phonePart) {
                    const phones = phonePart.split(/[\/|,]/).map(p => p.trim()).filter(p => p.length >= 6);
                    if (phones.length > 0) {
                       currentBlock.phones.push(...phones);
                    } else {
                       errors.push({ originalText: line, reason: "No valid phone numbers found (min 6 digits required after trimming).", lineNumber: currentLineNumber });
                    }
                } else {
                    errors.push({ originalText: line, reason: "Contact line found but no phone numbers provided after symbol.", lineNumber: currentLineNumber });
                }
            } else if (/name\:|áˆµáˆ\:/i.test(trimmedLine)) { // Check for Name
                 if (!currentBlock.date) {
                     errors.push({ originalText: line, reason: "Name found before a valid Date (ğŸ“… DD/MM/YYYY).", lineNumber: currentLineNumber });
                     continue;
                }
                 // Overwrite name if multiple lines found (take the last one)
                 currentBlock.name = trimmedLine.replace(/.*(name|áˆµáˆ)[:\s]?/i, '').trim();

            } else if (/comment\:|áŠ•á‰¥áˆ¨á‰µ\:/i.test(trimmedLine)) { // Check for Comment
                 if (!currentBlock.date) {
                     errors.push({ originalText: line, reason: "Comment found before a valid Date (ğŸ“… DD/MM/YYYY).", lineNumber: currentLineNumber });
                     continue;
                }
                 // Overwrite comment if multiple lines found (take the last one)
                 currentBlock.comment = trimmedLine.replace(/.*(comment|áŠ•á‰¥áˆ¨á‰µ)[:\s]?/i, '').trim();

            }
            else {
                // Line didn't match any expected pattern
                errors.push({ originalText: line, reason: "Line did not match any expected format (Date, Route, Contact, Name, or Comment).", lineNumber: currentLineNumber });
            }
        }

        // Push the last block after the loop finishes
         if (currentBlock.date || currentBlock.from || currentBlock.to || currentBlock.phones.length > 0 || currentBlock.name || currentBlock.comment) {
             entriesToProcess.push({...currentBlock}); // Push the last copy
         }


        // --- Step 2: Validate and prepare entries from parsed blocks ---
        const finalEntries = [];
        const processingErrors = [];
        let defaultNameCounter = 50; // Initialize default name counter

        entriesToProcess.forEach(block => {
             // Basic block validation (date, route, phones are essential)
             if (!block.date) {
                 processingErrors.push({ originalText: `Block starting line ${block.lineNumber}`, reason: "Missing or invalid Date for the block.", lineNumber: block.lineNumber });
                 return;
             }
             if (!block.from || !block.to) {
                 processingErrors.push({ originalText: `Block starting line ${block.lineNumber}`, reason: `Missing 'From' or 'To' in the route information.`, lineNumber: block.lineNumber });
                 return;
             }
             if (block.phones.length === 0) {
                 processingErrors.push({ originalText: `Block starting line ${block.lineNumber}`, reason: "No valid contact phone numbers found for this entry.", lineNumber: block.lineNumber });
                 return;
             }

             // If block is valid, create individual entries for each phone number
             const nFrom = normalizeCountry(block.from);
             const nTo = normalizeCountry(block.to);

             block.phones.forEach(phone => {
                 let entryName = block.name || ''; // Get name from block, default to empty string

                 // Assign default name if empty
                 if (!entryName) {
                     entryName = String(defaultNameCounter++).padStart(4, '0');
                 }

                 finalEntries.push({
                     date: block.date,
                     from: nFrom,
                     to: nTo,
                     contact: phone,
                     name: entryName, // Add assigned name
                     comment: block.comment || '', // Add comment, default to empty string
                     lineNumber: block.lineNumber // Associate entry with block start line
                 });
             });
        });

        // Combine initial parsing errors with block processing errors
        errors.push(...processingErrors);

        // --- Step 3: Process valid entries (Check duplicates and add to Firestore) ---
        let addedCount = 0;
        let skippedCount = 0;
        let failedCount = 0; // For errors during DB add
        const addedDetails = [];
        const skippedDetails = [];
        const addErrors = [];

        // Use a map to track duplicates within the current batch before checking DB
        // Duplicate key now includes name
        const batchDuplicates = new Set();

        for (const entry of finalEntries) {
            // Duplicate check key includes name
            const duplicateKey = `${entry.date}-${entry.from}-${entry.to}-${entry.contact}-${entry.name}`;

            if (batchDuplicates.has(duplicateKey)) {
                 // Duplicate within the current batch
                 skippedCount++;
                 skippedDetails.push({ entry: entry, reason: "Duplicate within the pasted list." });
                 continue;
            }

            batchDuplicates.add(duplicateKey); // Add to batch check set

            // Check against database
            try {
                // Duplicate check in DB also includes name
                const isDup = await isDuplicateEntry(entry.date, entry.from, entry.to, entry.contact, entry.name);
                if (isDup) {
                    skippedCount++;
                    skippedDetails.push({ entry: entry, reason: "Duplicate found in existing records." });
                } else {
                    // Add all fields to Firestore document
                    await addDoc(courierRef, {
                        date: entry.date,
                        from: entry.from,
                        to: entry.to,
                        contact: entry.contact,
                        name: entry.name,
                        comment: entry.comment,
                        createdAt: serverTimestamp()
                    });
                    addedCount++;
                    addedDetails.push({ entry: entry });
                }
            } catch (err) {
                failedCount++;
                addErrors.push({ entry: entry, reason: `Database add failed: ${err.message}` });
            }
        }

        // --- Step 4: Display Results ---

        // Overall Summary
        overallResult.textContent = `Process Complete: ${addedCount} added, ${skippedCount} skipped, ${errors.length + failedCount} failed/errors.`;
        if (addedCount > 0) overallResult.className = "mt-3 fw-bold text-success";
        else if (errors.length + failedCount > 0) overallResult.className = "mt-3 fw-bold text-danger";
        else if (skippedCount > 0) overallResult.className = "mt-3 fw-bold text-warning"; // Warning if only skips
        else overallResult.className = "mt-3 fw-bold text-secondary"; // Neutral if nothing happened


        // Helper to format entry details for display
        const formatEntryDisplay = (entry) => {
            let text = `${entry.name} (${entry.from} â†’ ${entry.to}) - ${entry.contact}`;
            if (entry.comment) {
                text += ` [${entry.comment}]`;
            }
            return text;
        };

        // Added List
        if (addedDetails.length > 0) {
            addedList.innerHTML = '<h5>âœ… Successfully Added:</h5>';
            addedDetails.forEach(item => {
                const p = document.createElement("p");
                p.className = "text-success";
                p.innerText = formatEntryDisplay(item.entry);
                addedList.appendChild(p);
            });
        }

        // Skipped List
        if (skippedDetails.length > 0) {
            skippedList.innerHTML = '<h5>â­ï¸ Skipped Entries:</h5>';
             skippedDetails.forEach(item => {
                const p = document.createElement("p");
                p.className = "text-warning";
                p.innerText = `${formatEntryDisplay(item.entry)} (Reason: ${item.reason})`;
                skippedList.appendChild(p);
            });
        }

        // Error List (Parsing + Processing + DB Add Errors)
        const allErrors = [...errors, ...addErrors];
        if (allErrors.length > 0) {
            errorList.innerHTML = '<h5>âŒ Errors Detected:</h5>';
            allErrors.forEach(err => {
                const p = document.createElement("p");
                p.className = "text-danger";
                let errorText = `Line ${err.lineNumber || 'N/A'}: ${err.reason}`;
                if (err.originalText) {
                    // Limit original text length for display
                    errorText += ` (Original: "${err.originalText.substring(0, 100)}${err.originalText.length > 100 ? '...' : ''}")`;
                } else if (err.entry) {
                    // Display entry details for DB errors
                     errorText += ` (Entry: ${formatEntryDisplay(err.entry)})`;
                }
                p.innerText = errorText;
                errorList.appendChild(p);
            });
        }


        // Clear input only on significant success, or maybe leave it? User preference.
        // For now, let's clear it if anything was added.
        if (addedCount > 0 && errors.length === 0 && failedCount === 0) { // Only clear if everything added without errors
             bulkInput.value = "";
        }


        // Hide loading spinner
        submitBtn.disabled = false;
        buttonText.style.display = 'inline-block';
        loadingSpinner.style.display = 'none';
    });
  </script>
</body>
</html>
