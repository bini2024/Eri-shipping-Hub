<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8">
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  <title>Bulk Courier Uploader - Eri Shipping Hub</title>
Â  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
Â  <style>
Â  Â  /* Basic styling for feedback messages */
Â  Â  .feedback-section p {
Â  Â  Â  margin-bottom: 0.25rem; /* Tighter spacing for list items */
Â  Â  Â  padding: 0.2rem 0;
Â  Â  }
Â  Â  .feedback-section h5 {
Â  Â  Â  Â  margin-top: 1rem;
Â  Â  Â  Â  margin-bottom: 0.5rem;
Â  Â  }
Â  Â  .spinner-border {
Â  Â  Â  Â  display: inline-block;
Â  Â  Â  Â  width: 1.5rem;
Â  Â  Â  Â  height: 1.5rem;
Â  Â  Â  Â  vertical-align: middle;
Â  Â  Â  Â  margin-right: 0.5rem;
Â  Â  }
Â  Â  pre {
Â  Â  Â  Â  white-space: pre-wrap; /* Allow example text to wrap */
Â  Â  Â  Â  word-wrap: break-word;
Â  Â  }
Â  </style>
</head>
<body class="bg-light">
Â  <div class="container py-5">
Â  Â  <h3 class="text-center mb-4">ğŸ“¦ Bulk Courier Uploader</h3>

Â  Â  <div class="card mb-4">
Â  Â  Â  Â  <div class="card-body">
Â  Â  Â  Â  Â  Â  <h5 class="card-title">Instructions for Pasting Data:</h5>
Â  Â  Â  Â  Â  Â  <p class="card-text">Paste your courier entries below. Each entry should be grouped together and include the following lines. Order within a group is flexible, but each line must start with the correct indicator:</p>
Â  Â  Â  Â  Â  Â  <ul>
Â  Â  Â  Â  Â  Â  Â  Â  <li>ğŸ“… **Date:** Must be on a line starting with 'ğŸ“… ' followed by the date in `DD/MM/YYYY` format (e.g., `ğŸ“… 27/04/2025`). This line signals the start of a new courier group.</li>
Â  Â  Â  Â  Â  Â  Â  Â  <li>ğŸ›£ï¸ **Route:** Must be on a line containing 'áˆ˜áŠ•áŒˆá‹²:' or 'â†’' or 'to', specifying the route like `áˆ˜áŠ•áŒˆá‹²: From â†’ To` or `From to To`.</li>
Â  Â  Â  Â  Â  Â  Â  Â  <li>ğŸ“ **Contact(s):** Must be on a line starting with 'ğŸ“ ' or 'áˆµáˆáŠª' or 'Phone', followed by one or more phone numbers separated by `/` or `,`. Each phone number will create a separate courier entry with the same date/route/name/comment. (e.g., `ğŸ“ 0910111030 / 0944406293`).</li>
Â  Â  Â  Â  Â  Â  Â  Â  Â <li>ğŸ‘¤ **Name / áˆµáˆ (Optional):** Must be on a line starting with 'name:' or 'áˆµáˆ:'. (e.g., `name: John Doe`). If not provided, a default name like '0050', '0051', etc., will be assigned.</li>
Â  Â  Â  Â  Â  Â  Â  Â  <li>ğŸ“ **Comment / áŠ•á‰¥áˆ¨á‰µ (Optional):** Must be on a line starting with 'comment:' or 'áŠ•á‰¥áˆ¨á‰µ:'. (e.g., `comment: 2 boxes, clothes`).</li>
Â  Â  Â  Â  Â  Â  </ul>
Â  Â  Â  Â  Â  Â  <p class="card-text fw-bold">Example:</p>
Â  Â  Â  Â  Â  Â  <pre class="bg-light p-2 border rounded">
ğŸ“… 27/04/2025
name: John Doe
áˆ˜áŠ•áŒˆá‹²: Canada â†’ Eritrea
ğŸ“ 0910111030 / 0944406293
comment: Suitcase with gifts

ğŸ“… 28/04/2025
From to Ethiopia
ğŸ“ 0912345678
# No name provided for this entry, a default will be assigned
comment: Small package</pre>
Â  Â  Â  Â  Â  Â  Â <p class="card-text text-muted"><small>**Duplicate entries (same date, from, to, and contact) will be skipped, regardless of the name.**</small></p>
Â  Â  Â  Â  </div>
Â  Â  </div>


Â  Â  <div class="mb-3">
Â  Â  Â  <label for="bulkInput" class="form-label">Paste entries below:</label>
Â  Â  Â  <textarea id="bulkInput" class="form-control" rows="12" placeholder="Paste your structured data here following the instructions above..."></textarea>
Â  Â  </div>

Â  Â  <button id="submitBulk" class="btn btn-primary">
Â  Â  Â  Â  <span id="buttonText">ğŸš€ Add All Couriers</span>
Â  Â  Â  Â  <span id="loadingSpinner" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display: none;"></span>
Â  Â  </button>
Â  Â  <p id="overallResult" class="mt-3 fw-bold"></p>

Â  Â  <div class="feedback-section mt-4">
Â  Â  Â  Â  <div id="addedList"></div>
Â  Â  Â  Â  <div id="skippedList"></div>
Â  Â  Â  Â  <div id="errorList"></div>
Â  Â  </div>

Â  </div>

Â  <script type="module">
Â  Â  // --- IMPORTANT FIREBASE CONFIG ---
Â  Â  // Replace with your actual Firebase configuration details
Â  Â  const firebaseConfig = {
Â  Â  Â  apiKey: "YOUR_API_KEY",
Â  Â  Â  authDomain: "YOUR_AUTH_DOMAIN",
Â  Â  Â  projectId: "YOUR_PROJECT_ID",
Â  Â  Â  storageBucket: "YOUR_STORAGE_BUCKET",
Â  Â  Â  messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
Â  Â  Â  appId: "YOUR_APP_ID"
Â  Â  };

Â  Â  // --- WARNING ---
Â  Â  // Based on the console errors you might have seen ('Host validation failed'),
Â  Â  // if you encounter them again, the issue is in Firebase's backend configuration,
Â  Â  // not this client-side code.

Â  Â  // --- Firebase SDK Imports ---
Â  Â  // Corrected import: included 'doc'
Â  Â  import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
Â  Â  import { getFirestore, collection, addDoc, serverTimestamp, query, where, getDocs, writeBatch, doc } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore.js";

Â  Â  // --- Firebase Initialization ---
Â  Â  const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp();
Â  Â  const db = getFirestore(app);
Â  Â  const courierRef = collection(db, "couriers"); // Target collection: 'couriers'

Â  Â  // --- DOM Elements ---
Â  Â  const bulkInput = document.getElementById("bulkInput");
Â  Â  const overallResult = document.getElementById("overallResult");
Â  Â  const addedList = document.getElementById("addedList");
Â  Â  const skippedList = document.getElementById("skippedList");
Â  Â  const errorList = document.getElementById("errorList");
Â  Â  const submitBtn = document.getElementById("submitBulk");
Â  Â  const buttonText = document.getElementById("buttonText");
Â  Â  const loadingSpinner = document.getElementById("loadingSpinner");

Â  Â  // --- Helper Functions ---

    // Helper to format date from DD/MM/YYYY to YYYY-MM-DD
    const formatDDMMYYYYtoYYYYMMDD = (dateStr) => {
        const parts = dateStr.split('/');
        if (parts.length === 3) {
            const day = parts[0];
            const month = parts[1];
            const year = parts[2];
            return `${year}-${month}-${day}`; // Returns YYYY-MM-DD string
        }
        return null; // Return null if format is unexpected
    };


Â  Â  // Normalize country names (case-insensitive matching)
Â  Â  const normalizeCountry = (place) => {
Â  Â  Â  const lowerCasePlace = place.trim().toLowerCase();
Â  Â  Â  const map = {
Â  Â  Â  Â  "áŠ£á‹²áˆµ": "Ethiopia",
Â  Â  Â  Â  "áŠ¡áŒ‹áŠ•á‹³": "Uganda",
Â  Â  Â  Â  "áŠ£áˆµáˆ˜áˆ«": "Eritrea",
Â  Â  Â  Â  "áŠ«áŠ“á‹³": "Canada",
Â  Â  Â  Â  "áŠ¤áˆ­á‰µáˆ«": "Eritrea",
Â  Â  Â  Â  "á‰¶áˆ®áŠ•á‰¶": "Canada",
Â  Â  Â  Â  "áŠ«áˆá“áˆ‹": "Uganda",
Â  Â  Â  Â  "áŠ¢á‰²á‹®á•á‹«": "Ethiopia",
Â  Â  Â  Â  "áŠ£áˆ˜áˆªáŠ«": "USA",
Â  Â  Â  Â  "áˆµá‹Šá‹˜áˆ­áˆ‹áŠ•á‹µ": "Switzerland",
Â  Â  Â  Â  "á‰±áˆ­áŠª": "Turkey",
Â  Â  Â  Â  "áŠ¥áŠ•áŒáˆŠá‹": "England",
Â  Â  Â  Â  "á‹°áŠ•áˆ›áˆ­áŠ­": "Denmark",
Â  Â  Â  Â  "áŒˆáˆ­áˆ˜áŠ•": "Germany",
Â  Â  Â  Â  "áˆáˆ¨áŠ•áˆ³": "France",
Â  Â  Â  Â  "áŠ¢á‰³áˆá‹«": "Italy",
Â  Â  Â  Â  "á‹°á‰¡á‰¥ áŠ£ááˆªá‰ƒ": "South Africa",
Â  Â  Â  Â  "áŠ¥áŒá•á‰µ": "Egypt"
Â  Â  Â  };
Â  Â  Â  // Check map for lowercase key, otherwise return trimmed original
Â  Â  Â  for (const key in map) {
Â  Â  Â  Â  Â  if (lowerCasePlace === key) {
Â  Â  Â  Â  Â  Â  Â  return map[key];
Â  Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return place.trim(); // Return trimmed original if not in map
Â  Â  };

Â  Â  // Basic date validation DD/MM/YYYY (used for input parsing)
Â  Â  const isValidDate = (dateStr) => {
Â  Â  Â  Â  if (!/^\d{2}\/\d{2}\/\d{4}$/.test(dateStr)) return false;
Â  Â  Â  Â  const parts = dateStr.split('/');
Â  Â  Â  Â  const day = parseInt(parts[0], 10);
Â  Â  Â  Â  const month = parseInt(parts[1], 10);
Â  Â  Â  Â  const year = parseInt(parts[2], 10);

Â  Â  Â  Â  if (year < 1000 || year > 3000 || month == 0 || month > 12) return false;
Â  Â  Â  Â  const date = new Date(year, month - 1, day);
Â  Â  Â  Â  return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
Â  Â  };

Â  Â  // Function to check for duplicate entries in Firestore
Â  Â  // This will now query using the YYYY-MM-DD format
Â  Â  async function isDuplicateEntry(dateYYYYMMDD, from, to, contact) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  // Basic validation before querying
Â  Â  Â  Â  Â  Â  if (!dateYYYYMMDD || !from || !to || !contact || contact.length < 6) {
Â  Â  Â  Â  Â  Â  Â  Â  Â console.warn("Skipping duplicate check due to incomplete data:", {dateYYYYMMDD, from, to, contact});
Â  Â  Â  Â  Â  Â  Â  Â  Â return false; // Cannot check for duplicates with incomplete data
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const q = query(
Â  Â  Â  Â  Â  Â  Â  Â  courierRef,
Â  Â  Â  Â  Â  Â  Â  Â  where("date", "==", dateYYYYMMDD), // Query using YYYY-MM-DD
Â  Â  Â  Â  Â  Â  Â  Â  where("from", "==", from),
Â  Â  Â  Â  Â  Â  Â  Â  where("to", "==", to),
Â  Â  Â  Â  Â  Â  Â  Â  where("contact", "==", contact)
Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  // This line performs the READ operation
Â  Â  Â  Â  Â  Â  const querySnapshot = await getDocs(q);
Â  Â  Â  Â  Â  Â  return !querySnapshot.empty;

Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  console.error("Error during duplicate check:", error);
Â  Â  Â  Â  Â  Â  throw new Error(`Duplicate check failed: ${error.message}`);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  // Helper to format entry details for display
Â  Â  const formatEntryDisplay = (entry) => {
Â  Â  Â  Â  // entry.date is now YYYY-MM-DD, but display as DD/MM/YYYY for user
Â  Â  Â  Â  const dateParts = entry.date.split('-'); // Split YYYY-MM-DD
         let displayDate = entry.date;
         if(dateParts.length === 3) {
             displayDate = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`; // Format back to DD/MM/YYYY
         }

Â  Â  Â  Â  let text = `${entry.name || 'N/A'} (${entry.from || 'N/A'} â†’ ${entry.to || 'N/A'}) - ${entry.contact || 'N/A'}`;
Â  Â  Â  Â  if (entry.comment) {
Â  Â  Â  Â  Â  Â  text += ` [${entry.comment}]`;
Â  Â  Â  Â  }
Â  Â  Â  Â  return `${displayDate}: ${text}`; // Include formatted date in display
Â  Â  };


Â  Â  // Function to update the UI feedback sections
Â  Â  const updateFeedbackUI = (addedDetails, skippedDetails, allErrors, addedCount, skippedCount, failedCount) => {
Â  Â  Â  Â  Â // Overall Summary
Â  Â  Â  Â  const totalProcessed = addedCount + skippedCount + failedCount;
Â  Â  Â  Â  overallResult.textContent = `Process Complete: ${addedCount} added, ${skippedCount} skipped, ${allErrors.length} failed/errors out of ${totalProcessed} attempted entries.`;
Â  Â  Â  Â  if (addedCount > 0 && allErrors.length === 0 && failedCount === 0) overallResult.className = "mt-3 fw-bold text-success";
Â  Â  Â  Â  else if (allErrors.length + failedCount > 0) overallResult.className = "mt-3 fw-bold text-danger";
Â  Â  Â  Â  else if (skippedCount > 0) overallResult.className = "mt-3 fw-bold text-warning";
Â  Â  Â  Â  else overallResult.className = "mt-3 fw-bold text-secondary";

Â  Â  Â  Â  // Added List
Â  Â  Â  Â  addedList.innerHTML = ''; // Clear previous content
Â  Â  Â  Â  if (addedDetails.length > 0) {
Â  Â  Â  Â  Â  Â  addedList.innerHTML = '<h5>âœ… Successfully Added:</h5>';
Â  Â  Â  Â  Â  Â  addedDetails.forEach(item => {
Â  Â  Â  Â  Â  Â  Â  Â  const p = document.createElement("p");
Â  Â  Â  Â  Â  Â  Â  Â  p.className = "text-success";
Â  Â  Â  Â  Â  Â  Â  Â  p.innerText = formatEntryDisplay(item.entry);
Â  Â  Â  Â  Â  Â  Â  Â  addedList.appendChild(p);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  // Skipped List
Â  Â  Â  Â  skippedList.innerHTML = ''; // Clear previous content
Â  Â  Â  Â  if (skippedDetails.length > 0) {
Â  Â  Â  Â  Â  Â  skippedList.innerHTML = '<h5>â­ï¸ Skipped Entries:</h5>';
Â  Â  Â  Â  Â  Â  Â skippedDetails.forEach(item => {
Â  Â  Â  Â  Â  Â  Â  Â  const p = document.createElement("p");
Â  Â  Â  Â  Â  Â  Â  Â  p.className = "text-warning";
Â  Â  Â  Â  Â  Â  Â  Â  p.innerText = `${formatEntryDisplay(item.entry)} (Reason: ${item.reason})`;
Â  Â  Â  Â  Â  Â  Â  Â  skippedList.appendChild(p);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  // Error List
Â  Â  Â  Â  errorList.innerHTML = ''; // Clear previous content
Â  Â  Â  Â  if (allErrors.length > 0) {
Â  Â  Â  Â  Â  Â  errorList.innerHTML = '<h5>âŒ Errors Detected:</h5>';
Â  Â  Â  Â  Â  Â  allErrors.forEach(err => {
Â  Â  Â  Â  Â  Â  Â  Â  const p = document.createElement("p");
Â  Â  Â  Â  Â  Â  Â  Â  p.className = "text-danger";
Â  Â  Â  Â  Â  Â  Â  Â  let errorText = `Line ${err.lineNumber || 'N/A'}: ${err.reason}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â if (err.entry) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  errorText += ` (Entry: ${formatEntryDisplay(err.entry)})`;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (err.originalText) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â errorText += ` (Original: "${err.originalText.substring(0, 100)}${err.originalText.length > 100 ? '...' : ''}")`;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  p.innerText = errorText;
Â  Â  Â  Â  Â  Â  Â  Â  errorList.appendChild(p);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  };

Â  Â  // Function to manage button loading state
Â  Â  const setButtonLoadingState = (isLoading) => {
Â  Â  Â  Â  submitBtn.disabled = isLoading;
Â  Â  Â  Â  buttonText.style.display = isLoading ? 'none' : 'inline-block';
Â  Â  Â  Â  loadingSpinner.style.display = isLoading ? 'inline-block' : 'none';
Â  Â  };


Â  Â  // --- Main Event Listener ---
Â  Â  submitBtn.addEventListener("click", async () => {
Â  Â  Â  Â  // Reset UI and state
Â  Â  Â  Â  setButtonLoadingState(true);
Â  Â  Â  Â  overallResult.textContent = "";
Â  Â  Â  Â  addedList.innerHTML = "";
Â  Â  Â  Â  skippedList.innerHTML = "";
Â  Â  Â  Â  errorList.innerHTML = "";
Â  Â  Â  Â  overallResult.className = "mt-3 fw-bold";

Â  Â  Â  Â  const lines = bulkInput.value.trim().split("\n");
Â  Â  Â  Â  let currentBlock = { date: '', from: '', to: '', phones: [], name: '', comment: '', lineNumber: -1 };
Â  Â  Â  Â  const entriesToProcess = [];
Â  Â  Â  Â  const parsingAndProcessingErrors = [];
Â  Â  Â  Â  let currentLineNumber = 0;
Â  Â  Â  Â  let defaultNameCounter = 50;


Â  Â  Â  Â  // --- Step 1: Parse and Group Data ---
Â  Â  Â  Â  for (const line of lines) {
Â  Â  Â  Â  Â  Â  currentLineNumber++;
Â  Â  Â  Â  Â  Â  const trimmedLine = line.trim();
Â  Â  Â  Â  Â  Â  if (!trimmedLine || trimmedLine.startsWith('#')) continue;

Â  Â  Â  Â  Â  Â  if (trimmedLine.startsWith('ğŸ“…')) {
Â  Â  Â  Â  Â  Â  Â  Â  if (currentBlock.date || currentBlock.from || currentBlock.to || currentBlock.phones.length > 0 || currentBlock.name || currentBlock.comment) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Before starting a new block, validate and push the completed block's entries
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if(currentBlock.date && currentBlock.from && currentBlock.to && currentBlock.phones.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const nFrom = normalizeCountry(currentBlock.from);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const nTo = normalizeCountry(currentBlock.to);
                           const dateYYYYMMDD = formatDDMMYYYYtoYYYYMMDD(currentBlock.date); // Format date for saving

                           if (dateYYYYMMDD) {
                               currentBlock.phones.forEach(phone => {
                                   let entryName = currentBlock.name || String(defaultNameCounter++).padStart(4, '0');
                                   entriesToProcess.push({
                                       date: dateYYYYMMDD, // Save as YYYY-MM-DD
                                       from: nFrom,
                                       to: nTo,
                                       contact: phone.trim(),
                                       name: entryName,
                                       comment: currentBlock.comment || '',
                                       lineNumber: currentBlock.lineNumber // Associate entry with block start line
                                   });
                               });
                           } else {
                                parsingAndProcessingErrors.push({ originalText: `Block starting line ${currentBlock.lineNumber}`, reason: "Failed to format date to YYYY-MM-DD.", lineNumber: currentBlock.lineNumber });
                           }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Block was incomplete/invalid, log a processing error for the block
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentBlock.lineNumber !== -1) { // Only log if a block was actually started
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let reason = "Incomplete block detected (missing Date, Route, or Contact phones).";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (!currentBlock.date) reason = "Missing or invalid Date for block.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â else if (!currentBlock.from || !currentBlock.to) reason = "Missing or invalid Route for block.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â else if (currentBlock.phones.length === 0) reason = "No valid Contact phones for block.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â parsingAndProcessingErrors.push({ originalText: `Block starting line ${currentBlock.lineNumber}`, reason: reason, lineNumber: currentBlock.lineNumber });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // Start a new block with the date (date still stored as DD/MM/YYYY initially)
Â  Â  Â  Â  Â  Â  Â  Â  const dateMatch = trimmedLine.match(/\d{2}\/\d{2}\/\d{4}/);
Â  Â  Â  Â  Â  Â  Â  Â  if (dateMatch && isValidDate(dateMatch[0])) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentBlock = { date: dateMatch[0], from: '', to: '', phones: [], name: '', comment: '', lineNumber: currentLineNumber };
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â parsingAndProcessingErrors.push({ originalText: line, reason: "Invalid or missing date format (DD/MM/YYYY) after ğŸ“… symbol.", lineNumber: currentLineNumber });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â currentBlock = { date: '', from: '', to: '', phones: [], name: '', comment: '', lineNumber: currentLineNumber }; // Reset block
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  } else if (currentBlock.date) { // Only process other lines if a date block has started
Â  Â  Â  Â  Â  Â  Â  Â  Â if (/áˆ˜áŠ•áŒˆá‹²\:|â†’|to/i.test(trimmedLine)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentBlock.from || currentBlock.to) { // Check if route already set in this block
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â parsingAndProcessingErrors.push({ originalText: line, reason: "Duplicate Route line within the same entry block.", lineNumber: currentLineNumber });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â continue; // Skip this line but keep the current block
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let parts = trimmedLine.split(/â†’|to/i);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (parts.length === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentBlock.from = parts[0].replace(/.*(áˆ˜áŠ•áŒˆá‹²\:|â†’|to)/i, "").trim(); // More robust replace
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentBlock.to = parts[1].trim();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  parsingAndProcessingErrors.push({ originalText: line, reason: "Could not parse route format. Expected 'From â†’ To' or 'From to To'.", lineNumber: currentLineNumber });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  } else if (/ğŸ“|áˆµáˆáŠª|Phone/i.test(trimmedLine)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const phonePart = trimmedLine.replace(/.*(ğŸ“|áˆµáˆáŠª|Phone)[:\s]?/i, '').trim();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (phonePart) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const phones = phonePart.split(/[\/|,]/).map(p => p.trim()).filter(p => p.length >= 6);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (phones.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â currentBlock.phones.push(...phones);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â parsingAndProcessingErrors.push({ originalText: line, reason: "No valid phone numbers found (min 6 digits required after trimming).", lineNumber: currentLineNumber });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  parsingAndProcessingErrors.push({ originalText: line, reason: "Contact line found but no phone numbers provided after symbol.", lineNumber: currentLineNumber });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else if (/name\:|áˆµáˆ\:/i.test(trimmedLine)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â currentBlock.name = trimmedLine.replace(/.*(name|áˆµáˆ)[:\s]?/i, '').trim();

Â  Â  Â  Â  Â  Â  Â  Â  } else if (/comment\:|áŠ•á‰¥áˆ¨á‰µ\:/i.test(trimmedLine)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â currentBlock.comment = trimmedLine.replace(/.*(comment|áŠ•á‰¥áˆ¨á‰µ)[:\s]?/i, '').trim();

Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â parsingAndProcessingErrors.push({ originalText: line, reason: "Line did not match expected format within a date block.", lineNumber: currentLineNumber });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â // Line appeared before any date block marker
Â  Â  Â  Â  Â  Â  Â  Â  Â  parsingAndProcessingErrors.push({ originalText: line, reason: "Line appeared before any Date (ğŸ“…) marker.", lineNumber: currentLineNumber });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // Process the last block after the loop
Â  Â  Â  Â  if(currentBlock.date && currentBlock.from && currentBlock.to && currentBlock.phones.length > 0) {
Â  Â  Â  Â  Â  Â  const nFrom = normalizeCountry(currentBlock.from);
Â  Â  Â  Â  Â  Â  const nTo = normalizeCountry(currentBlock.to);
             const dateYYYYMMDD = formatDDMMYYYYtoYYYYMMDD(currentBlock.date); // Format date for saving

             if (dateYYYYMMDD) {
                 currentBlock.phones.forEach(phone => {
                     let entryName = currentBlock.name || String(defaultNameCounter++).padStart(4, '0');
                     entriesToProcess.push({
                         date: dateYYYYMMDD, // Save as YYYY-MM-DD
                         from: nFrom,
                         to: nTo,
                         contact: phone.trim(),
                         name: entryName,
                         comment: currentBlock.comment || '',
                         lineNumber: currentBlock.lineNumber
                     });
                 });
             } else {
                  parsingAndProcessingErrors.push({ originalText: `Final block starting line ${currentBlock.lineNumber}`, reason: "Failed to format date to YYYY-MM-DD.", lineNumber: currentBlock.lineNumber });
             }

Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â // Log processing error for the last block if incomplete
Â  Â  Â  Â  Â  Â  Â if (currentBlock.lineNumber !== -1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â let reason = "Incomplete final block detected (missing Date, Route, or Contact phones).";
Â  Â  Â  Â  Â  Â  Â  Â  Â if (!currentBlock.date) reason = "Missing or invalid Date for the final block.";
Â  Â  Â  Â  Â  Â  Â  Â  Â else if (!currentBlock.from || !currentBlock.to) reason = "Missing or invalid Route for the final block.";
Â  Â  Â  Â  Â  Â  Â  Â  Â else if (currentBlock.phones.length === 0) reason = "No valid Contact phones for the final block.";
Â  Â  Â  Â  Â  Â  Â  Â  Â parsingAndProcessingErrors.push({ originalText: `Final block starting line ${currentBlock.lineNumber}`, reason: reason, lineNumber: currentBlock.lineNumber });
Â  Â  Â  Â  Â  Â  Â } else if (lines.length > 0 && entriesToProcess.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â // Handle case where input had lines but no valid blocks at all
Â  Â  Â  Â  Â  Â  Â  Â  Â  parsingAndProcessingErrors.push({ originalText: "Input had lines but no valid entry blocks were parsed.", reason: "No valid entries found in the input data." });
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  }


Â  Â  Â  Â  // --- Step 2: Process valid entries (Check duplicates and add to Firestore) ---
Â  Â  Â  Â  let addedCount = 0;
Â  Â  Â  Â  let skippedCount = 0;
Â  Â  Â  Â  let failedCount = 0;
Â  Â  Â  Â  const addedDetails = [];
Â  Â  Â  Â  const skippedDetails = [];
Â  Â  Â  Â  const addErrors = [];
Â  Â  Â  Â  const batchDuplicates = new Set(); // Track duplicates within the current batch

Â  Â  Â  Â  // Use a batch for writing for efficiency
Â  Â  Â  Â  const batch = writeBatch(db);

Â  Â  Â  Â  for (const entry of entriesToProcess) {
Â  Â  Â  Â  Â  Â  // Duplicate check key uses the YYYY-MM-DD format now
Â  Â  Â  Â  Â  Â  const duplicateKey = `${entry.date}-${entry.from}-${entry.to}-${entry.contact}`;

Â  Â  Â  Â  Â  Â  if (batchDuplicates.has(duplicateKey)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â skippedCount++;
Â  Â  Â  Â  Â  Â  Â  Â  Â skippedDetails.push({ entry: entry, reason: "Duplicate within the pasted list." });
Â  Â  Â  Â  Â  Â  Â  Â  Â continue;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  batchDuplicates.add(duplicateKey);

Â  Â  Â  Â  Â  Â  // Check against database (This is the step expected to fail due to 'Host validation failed')
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  // isDuplicateEntry now expects YYYY-MM-DD
Â  Â  Â  Â  Â  Â  Â  Â  const isDup = await isDuplicateEntry(entry.date, entry.from, entry.to, entry.contact);

Â  Â  Â  Â  Â  Â  Â  Â  if (isDup) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  skippedCount++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  skippedDetails.push({ entry: entry, reason: "Duplicate found in existing records (Date, Route, Contact match)." });
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Add to batch, don't commit yet
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newCourierDocRef = doc(courierRef); // Get a new document reference with an auto-generated ID
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  batch.set(newCourierDocRef, {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  date: entry.date, // Save as YYYY-MM-DD
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  from: entry.from,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  to: entry.to,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  contact: entry.contact,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  name: entry.name,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  comment: entry.comment,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  createdAt: serverTimestamp()
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  addedDetails.push({ entry: entry }); // Add to addedDetails list now, will confirm after batch commit
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  Â  Â  Â  // Catch errors during the duplicate check (Host validation failed)
Â  Â  Â  Â  Â  Â  Â  Â  failedCount++;
Â  Â  Â  Â  Â  Â  Â  Â  addErrors.push({ entry: entry, reason: `Duplicate check failed: ${err.message}` });
Â  Â  Â  Â  Â  Â  Â  Â  Â // Stop processing if duplicate check fails for one entry due to a fundamental error like host validation
Â  Â  Â  Â  Â  Â  Â  Â  Â // Otherwise, the console gets spammed and subsequent calls will also fail.
Â  Â  Â  Â  Â  Â  Â  Â  Â // If you want to try adding other entries even if check fails, remove the break;
Â  Â  Â  Â  Â  Â  Â  Â  break; // Stop processing entries if duplicate check fails
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Step 3: Commit the batch if there are entries to add ---
Â  Â  Â  Â  let batchCommitSuccessful = false;
Â  Â  Â  Â  if (addedDetails.length > 0) {
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  await batch.commit();
Â  Â  Â  Â  Â  Â  Â  Â  addedCount = addedDetails.length; // Confirm adds based on successful batch
Â  Â  Â  Â  Â  Â  Â  Â  batchCommitSuccessful = true;
Â  Â  Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  Â  Â  Â  // Catch errors during the batch commit
Â  Â  Â  Â  Â  Â  Â  Â  failedCount += addedDetails.length; // All entries in the batch failed
Â  Â  Â  Â  Â  Â  Â  Â  addErrors.push({ reason: `Batch commit failed: ${err.message}`, entry: null }); // Log a single batch error
Â  Â  Â  Â  Â  Â  Â  Â  Â // If batch commit fails, all entries marked for adding actually failed
Â  Â  Â  Â  Â  Â  Â  Â  Â addedDetails.length = 0; // Clear addedDetails as they didn't actually add
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }


Â  Â  Â  Â  // --- Step 4: Display Results and Reset UI ---
Â  Â  Â  Â  const allErrors = [...parsingAndProcessingErrors, ...addErrors];
Â  Â  Â  Â  updateFeedbackUI(addedDetails, skippedDetails, allErrors, addedCount, skippedCount, failedCount);


Â  Â  Â  Â  // Clear input only on significant success (all processed, no errors)
Â  Â  Â  Â  if (batchCommitSuccessful && parsingAndProcessingErrors.length === 0 && skippedCount === 0) {
Â  Â  Â  Â  Â  Â  Â // bulkInput.value = ""; // User preference whether to clear or not
Â  Â  Â  Â  }


Â  Â  Â  Â  setButtonLoadingState(false);
Â  Â  });
Â  </script>
</body>
</html>
